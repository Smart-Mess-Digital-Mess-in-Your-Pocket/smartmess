<!-- Copilot / AI agent guidance for the SmartMess Flutter app -->
# SmartMess — Copilot Instructions

This file provides concise, repository-specific guidance for AI coding agents working on SmartMess.

**Big Picture**
- **What:** Flutter mobile app (Android/iOS) using Firebase for Auth and Firestore as primary data store.
- **Main entry:** `lib/main.dart` — contains app bootstrap, Firebase initialization, routing and many UI screens. Treat it as the single source that wires flows.
- **Service layer:** `lib/services/` — small wrapper classes:
  - `auth_service.dart` — thin wrapper around `firebase_auth` for sign-in / register.
  - `database_service.dart` — core Firestore access: `users` and `messes` collections, with subcollections like `meals`, `costs`, `deposits`.
- **Data model highlights:**
  - User doc fields: `name`, `email`, `phone`, `role` (`"manager"` | `"member"`), optional `messId`, optional `totalDeposit`.
  - Mess doc fields: `messName`, `managerId`, `inviteCode`, `members` (array of UIDs). Meal documents are stored under `messes/{messId}/meals/{dateId}` where `dateId` starts with `YYYY-MM`.

**Critical flows & where to change them**
- Auth flow: `SplashScreen` (in `lib/main.dart`) checks `FirebaseAuth.instance.currentUser` then loads Firestore user doc via `DatabaseService(uid: uid).getUserData()` and navigates:
  - `role == 'manager'` -> `MessManagerScreen`
  - `role == 'member'` with `messId` -> `MemberDashboardScreen`
  - `role == 'member'` without `messId` -> `JoinMessScreen`
- Manager creation + invite: `DatabaseService.createMess(...)` generates an `inviteCode` and writes `messId` to the manager's user doc.
- Joining a mess: `DatabaseService.joinMessWithCode(inviteCode)` finds mess by inviteCode, updates both mess.members and user.doc.messId.

**Project-specific conventions & patterns**
- Role-based routing is enforced in UI before navigation (see `AuthScreen` login flow). Avoid bypassing this check — changes may introduce inconsistent UX.
- Date keys for meals are string IDs starting with `YYYY-MM` (code uses string-prefix queries). Keep this format when reading/writing meal docs.
- DatabaseService returns raw Firestore snapshots/maps. UI code expects to cast `.data()` to `Map<String, dynamic>` and mutate or add fields like `uid` and `messName`. Respect that pattern.
- Error handling: services prefer `try/catch` with `debugPrint(e.toString())` and returning graceful defaults. Follow this pattern when adding new DB helpers.

**Build / run / test commands (Windows powershell)**
- Install deps: `flutter pub get`
- Run on connected device/emulator: `flutter run -d <device-id>`
- Build APK: `flutter build apk --release`
- Run tests: `flutter test` (there is a `test/widget_test.dart` placeholder).
- Firebase setup note: `lib/firebase_options.dart` is present (generated by FlutterFire). Android config is at `android/app/google-services.json`.

**Integration points & external deps**
- Firebase services used: `firebase_core`, `firebase_auth`, `cloud_firestore` (see `pubspec.yaml`).
- Android: `android/app/google-services.json` is already included. iOS uses `firebase_options.dart` and Xcode project settings in `ios/Runner`.
- If switching Firebase projects or regenerating Firebase config, run FlutterFire CLI to regenerate `lib/firebase_options.dart` and add platform files.

**Files to inspect when changing behavior**
- `lib/main.dart` — app wiring, role-routing, many screens.
- `lib/services/database_service.dart` — central Firestore logic; updating schemas should update callers here.
- `lib/services/auth_service.dart` — auth wrappers.
- `android/app/google-services.json` and `lib/firebase_options.dart` — Firebase configuration.
- `pubspec.yaml` — dependency versions.

**Examples (copyable snippets)**
- Initialize Firebase: `await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);` (in `main()`)
- Fetch user doc: `var userDoc = await DatabaseService(uid: user.uid).getUserData();` then `var userData = userDoc.data() as Map<String, dynamic>;`
- Query mess by invite: `messCollection.where('inviteCode', isEqualTo: inviteCode).limit(1).get();`

**When to ask the human**
- Schema migrations that change field names (e.g., rename `messId` or `totalDeposit`) — this affects both DB and dozens of UI locations.
- Any Firebase project swap (new project IDs) — requires regenerated `firebase_options.dart` + platform files.

If anything here is unclear or you want a stricter convention (tests, linters, commit hooks), tell me which area to expand and I will iterate.
